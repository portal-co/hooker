{"mappings":";;;;;;;;;;;;;;ACEO,MAAM,4CAAY,YAAY;AAC9B,MAAM,4CAAsB,8CAAc,YAAY,YAAY,CAAA,GAAA,yCAAY,EAAE,0CAAU,SAAS;AACnG,MAAM,4CAAe,YAAY;AACjC,MAAM,4CAAc,YAAY;AAChC,MAAM,4CAAwB,8CAAgB,YAAY,YAAY,CAAA,GAAA,yCAAY,EAAE,0CAAY,SAAS;AACzG,MAAM,4CAAW,YAAY;AAC7B,MAAM,4CAAqB,8CAAa,YAAY,YAAY,CAAA,GAAA,yCAAY,EAAE,0CAAS,SAAS;;;ADRhG,SAAS,0CAAkB,EAAwB;IACtD,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACxB;AAGO,SAAS,0CAAgC,GAAM;IAClD,IAAI,mBAAmB,CAAC;IACxB,KAAK,IAAI,OAAO,OAAO,IAAI,CAAC,KAAM;QAC9B,IAAI;QACJ,IAAI,AAAC,CAAA,UAAU,GAAG,CAAC,IAAI,AAAD,aAAc,UAAU,gBAAgB,CAAC,IAAI,GAAG,0CAAS;IACnF;IACA,OAAO;AACX","sources":["snap/index.ts","snap/extras.ts"],"sourcesContent":["export function snapshot<T, U, V>(fn: (this: T, ...U) => V): (self: T, ...U) => V {\n    return fn.call.bind(fn);\n}\nexport type SnapshotInput<T, U, V> = (this: T, ...U) => V;\nexport type ProtoSnapshot<T> = { [Prop in keyof T]: T[Prop] extends SnapshotInput<infer T2, infer U, infer V> ? (self: T2, ...U) => V : never };\nexport function snapshotProto<T extends object>(val: T): ProtoSnapshot<T> {\n    let wipProtoSnapshot = {};\n    for (let key of Object.keys(val)) {\n        let wrapped;\n        if ((wrapped = val[key]) instanceof Function) wipProtoSnapshot[key] = snapshot(wrapped);\n    }\n    return wipProtoSnapshot as ProtoSnapshot<T>;\n}\nexport * from \"./extras.ts\"","\nimport { snapshotProto } from \"./index.ts\";\nexport const _DataView = globalThis?.DataView;\nexport const _DataView_prototype = _DataView === undefined ? undefined : snapshotProto(_DataView.prototype);\nexport const _ArrayBuffer = globalThis?.ArrayBuffer;\nexport const _Uint8Array = globalThis?.Uint8Array;\nexport const _Uint8Array_prototype = _Uint8Array === undefined ? undefined : snapshotProto(_Uint8Array.prototype);\nexport const _WeakMap = globalThis?.WeakMap;\nexport const _WeakMap_prototype = _WeakMap === undefined ? undefined : snapshotProto(_WeakMap.prototype);\n"],"names":[],"version":3,"file":"index.js.map"}