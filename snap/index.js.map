{"mappings":";;;;;;;;;;;;;;ACEO,MAAM,4CAAY,YAAY;AAC9B,MAAM,4CAAsB,8CAAc,YAAY,YAAY,CAAA,GAAA,yCAAY,EAAE,0CAAU,SAAS;AAEnG,MAAM,4CAAe,YAAY;AAEjC,MAAM,4CAAc,YAAY;AAChC,MAAM,4CAAwB,8CAAgB,YAAY,YAAY,CAAA,GAAA,yCAAY,EAAE,0CAAY,SAAS;AAEzG,MAAM,4CAAW,YAAY;AAC7B,MAAM,4CAAqB,8CAAa,YAAY,YAAY,CAAA,GAAA,yCAAY,EAAE,0CAAS,SAAS;;;ADXhG,SAAS,0CAAkB,EAAwB;IACtD,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACxB;AAGO,SAAS,0CAAgC,GAAM;IAClD,IAAI,IAAI,CAAC;IACT,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,KAAM;QAC5B,IAAI;QACJ,IAAI,AAAC,CAAA,UAAU,GAAG,CAAC,EAAE,AAAD,aAAc,UAAU,CAAC,CAAC,EAAE,GAAG,0CAAS;IAChE;IACA,OAAO;AACX","sources":["snap/index.ts","snap/extras.ts"],"sourcesContent":["export function snapshot<T, U, V>(fn: (this: T, ...U) => V): (self: T, ...U) => V {\n    return fn.call.bind(fn);\n}\nexport type SnapshotInput<T, U, V> = (this: T, ...U) => V;\nexport type ProtoSnapshot<T> = { [Prop in keyof T]: T[Prop] extends SnapshotInput<infer T2, infer U, infer V> ? (self: T2, ...U) => V : never };\nexport function snapshotProto<T extends object>(val: T): ProtoSnapshot<T> {\n    let a = {};\n    for (let k of Object.keys(val)) {\n        let wrapped;\n        if ((wrapped = val[k]) instanceof Function) a[k] = snapshot(wrapped);\n    }\n    return a as ProtoSnapshot<T>;\n}\nexport * from \"./extras.ts\"","\nimport { snapshotProto } from \"./index.ts\";\nexport const _DataView = globalThis?.DataView;\nexport const _DataView_prototype = _DataView === undefined ? undefined : snapshotProto(_DataView.prototype) \n\nexport const _ArrayBuffer = globalThis?.ArrayBuffer;\n\nexport const _Uint8Array = globalThis?.Uint8Array;\nexport const _Uint8Array_prototype = _Uint8Array === undefined ? undefined : snapshotProto(_Uint8Array.prototype) \n\nexport const _WeakMap = globalThis?.WeakMap;\nexport const _WeakMap_prototype = _WeakMap === undefined ? undefined : snapshotProto(_WeakMap.prototype) \n"],"names":[],"version":3,"file":"index.js.map"}