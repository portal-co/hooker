{"mappings":";;;;;;;;;;;;;;ACGO,MAAM,4CAAY;AAClB,MAAM,4CAAsB,CAAA,GAAA,yCAAY,EAAE,0CAAU,SAAS;AAG7D,MAAM,4CAAe;AAIrB,MAAM,4CAAc;AACpB,MAAM,4CAAwB,CAAA,GAAA,yCAAY,EAAE,0CAAY,SAAS;AAGjE,MAAM,4CAAW;AACjB,MAAM,4CAAqB,CAAA,GAAA,yCAAY,EAAE,0CAAS,SAAS;;;ADhB3D,SAAS,0CAAkB,EAAwB;IACtD,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACxB;AAGO,SAAS,0CAAgC,GAAM;IAClD,IAAI,IAAI,CAAC;IACT,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,KAAM;QAC5B,IAAI;QACJ,IAAI,AAAC,CAAA,UAAU,GAAG,CAAC,EAAE,AAAD,aAAc,UAAU,CAAC,CAAC,EAAE,GAAG,0CAAS;IAChE;IACA,OAAO;AACX","sources":["snap/index.ts","snap/extras.ts"],"sourcesContent":["export function snapshot<T, U, V>(fn: (this: T, ...U) => V): (self: T, ...U) => V {\n    return fn.call.bind(fn);\n}\nexport type SnapshotInput<T, U, V> = (this: T, ...U) => V;\nexport type ProtoSnapshot<T> = { [Prop in keyof T]: T[Prop] extends SnapshotInput<infer T2, infer U, infer V> ? (self: T2, ...U) => V : never };\nexport function snapshotProto<T extends object>(val: T): ProtoSnapshot<T> {\n    let a = {};\n    for (let k of Object.keys(val)) {\n        let wrapped;\n        if ((wrapped = val[k]) instanceof Function) a[k] = snapshot(wrapped);\n    }\n    return a as ProtoSnapshot<T>;\n}\nexport * from \"./extras.ts\"","\nimport { snapshotProto } from \"./index.ts\";\n\nexport const _DataView = DataView;\nexport const _DataView_prototype = snapshotProto(_DataView.prototype) \n\n\nexport const _ArrayBuffer = ArrayBuffer;\n\n\n\nexport const _Uint8Array = Uint8Array;\nexport const _Uint8Array_prototype = snapshotProto(_Uint8Array.prototype) \n\n\nexport const _WeakMap = WeakMap;\nexport const _WeakMap_prototype = snapshotProto(_WeakMap.prototype) \n\n"],"names":[],"version":3,"file":"index.js.map"}