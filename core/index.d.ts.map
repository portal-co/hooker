{"mappings":"AAGA,OAAO,MAAM,8BAAoB,CAAC;AAClC,OAAO,MAAM,qDAAoD,CAAA;AAGjE,OAAO,MAAM,oCAA0B,CAAC;AAIxC,OAAO,MAAM,kCAAwB,CAAC;AACtC,OAAO,MAAM,yDAAwD,CAAA;ACZrE,OAAO,IAAI,WAAc,CAAC;AAC1B,OAAO,IAAI,UAAU,OAAO,OAAwB,CAAC;AACrD,OAAO,IAAI,aAAa,OAAO,CAAC,GAAG,EAAE,GAAG,CAAiB,CAAC;AAC1D,qBAAqB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,OAAA,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,OAAA,KAAK,CAAC,CAE5E;AACD,sBAAsB,CAAC,IAAI;KAAG,IAAI,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE,GAAG,CAAC,OAAA,KAAK,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,GAAG,CAAC,OAAA,KAAK,CAAC,GAAG,KAAK;CAAE,CAAC;AACpI,0BAA0B,CAAC,SAAS,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,UAAU,CAAC,CAAC,CAMhE;AAED,qBAAqB,CAAC,SAAS;KAAG,CAAC,IAAI,CAAC,GAAG,MAAM;CAAE,EAAE,CAAC,SAAS,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,EAAE,eAAe,KAAK,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QA2BtI;AACD,yBAAyB,CAAC,SAAS;KAAG,CAAC,IAAI,CAAC,GAAG,GAAG;CAAE,EAAE,CAAC,SAAS,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,uBAAuB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,KAAK,uBAAuB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAKtK;AACD,OAAO,IAAI,QAAQ,OAAO,CAAC,KAAK,EAAE,KAAK,CAAiB,CAAC;AACzD,0BAA0B,CAAC,SAAS,WAAW,EAAE,EAAE,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,OAAO,EAAE,eAAe,EAAE,IAAI,EAAE,MAAM,KAAK,YAAY,CAAC,KAAK,CAAC,QAkCnI","sources":["core/core/extras.ts","core/core/index.ts","core/index.ts"],"sourcesContent":[null,null,"export let _Proxy = Proxy;\nexport let _Reflect: typeof Reflect = { ...Reflect };\nexport let hookProxies: WeakMap<any, any> = new WeakMap();\nexport function snap<T, U, V>(fn: (this: T, ...U) => V): (self: T, ...U) => V {\n    return fn.call.bind(fn);\n}\nexport type ProtoSnap<T> = { [Prop in keyof T]: T[Prop] extends (this: infer T2, ...U) => infer V ? (self: T2, ...U) => V : never };\nexport function snapProto<T extends object>(val: T): ProtoSnap<T> {\n    let a = {};\n    for (let k of Object.keys(val)) {\n        a[k] = snap(val[k])\n    }\n    return a as ProtoSnap<T>;\n}\n\nexport function hook<T extends { [a in K]: object }, K extends keyof T>(a: T, b: K, c: (Reflect: typeof _Reflect) => ProxyHandler<T[K]>) {\n    // a[b] = new _Proxy(a[b], c(_Reflect));\n    hookProp(a, b, d => ((d = d || { value: undefined }), {\n        configurable: d?.configurable ?? true,\n        enumerable: d?.enumerable ?? true,\n        writable: d?.writable ?? true,\n        get() {\n            var p: T[K], v: T[K];\n            if (d?.get) {\n                p = new _Proxy(v = d!.get!(), c(_Reflect));\n            } else {\n                p = new _Proxy(v = d!.value!, c(_Reflect));\n            }\n            hookProxies.set(p, v);\n            return p;\n        },\n        set(value) {\n            while (hookProxies.has(value)) {\n                value = hookProxies.get(value)!;\n            }\n            if (d?.set) {\n                d!.set!(value)\n            } else {\n                d.value = value;\n            }\n        }\n    }));\n}\nexport function hookProp<T extends { [a in K]: any }, K extends keyof T>(a: T, b: K, c: (d: TypedPropertyDescriptor<T[K]> | undefined) => TypedPropertyDescriptor<T[K]>) {\n    let d = _Reflect.getOwnPropertyDescriptor(a, b);\n    // if (d !== undefined) {\n    _Reflect.defineProperty(a, b, c(d));\n    // }\n}\nexport let events: WeakMap<Event, Event> = new WeakMap();\nexport function hookEvent<T extends EventTarget>(ev: T, event_proxy: (Reflect: typeof _Reflect, name: string) => ProxyHandler<Event>) {\n    let m: WeakMap<any, any> = new WeakMap();\n    hook(ev, \"addEventListener\", Reflect => ({\n        apply(target, thisArg, argArray) {\n            let handler = argArray[1];\n            let name;\n            let h2 = $ => {\n                let e = new _Proxy($, event_proxy(Reflect, name));\n                events.set(e, $);\n                handler(e);\n            };\n            m.set(handler, h2);\n            return Reflect.apply(target, thisArg, [name = argArray[0], h2]);\n        },\n    }));\n    hook(ev, \"removeEventListener\", Reflect => ({\n        apply(target, thisArg, argArray) {\n            let handler = argArray[1];\n            let h2 = m.get(handler);\n            m.delete(handler);\n            return Reflect.apply(target, thisArg, [argArray[0], h2]);\n        },\n    }));\n    if (ev instanceof EventSource) {\n        hook(ev, \"dispatchEvent\", Reflect => ({\n            apply(target, thisArg, argArray) {\n                var ev = argArray[0];\n                if (events.has(ev)) {\n                    ev = events.get(ev)!;\n                }\n                return Reflect.apply(target, thisArg, [ev])\n            },\n        }));\n    }\n}\nexport * from './extras.ts'"],"names":[],"version":3,"file":"index.d.ts.map"}